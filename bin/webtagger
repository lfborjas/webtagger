#!/usr/bin/env ruby
require 'optparse'
require 'fileutils'
$:.unshift File.dirname(__FILE__) + "/../lib"

require 'webtagger'

service = ""

def configure
    WebTagger::SERVICES.each do |service|
        next if service == "tagthe"
        conf = File.join(ENV['HOME'], '.webtagger')
        FileUtils.touch(conf) unless File.exist? conf
        srvcs = {}
        File.open(conf).each do |service_conf|
            s, t = service_conf.split(/\s*=\s*/) rescue next
            srvcs[s.strip.downcase] = t ? t.strip : "" 
        end
        puts "Token for #{service.downcase} (leave blank if you don't want to set it now or you already did): "
        token = gets
        srvcs[service]= (token and not token.strip.empty?) ? token : srvcs[service] || ""
        File.open(conf,'w') do |new_conf|
            srvcs.each do |s, t|
                new_conf.write("#{s.upcase}=#{t.strip}\n")
            end
        end
    end
end

OptionParser.new do |opt|
    opt.banner = "usage: webtagger [OPTIONS] [text]"
    opt.on('-c', '--configure', String, "Add tokens for each service") do
        configure()
        exit
    end

    opt.on('-t', '--token=[service]', String, "Get the token of a specific service (or all if not specified)") do |s|
        s="all" if not s or s.empty?
        puts WebTagger.get_token(s)
        exit
    end
    opt.on('-s', '--service=[service]', String, "Tag the text with the specified service (defaults to tagthe)") do |s|
        s="" unless WebTagger::SERVICES.include?(s)
        service = s
    end
    opt.on('-h', '--help', "Display the help screen and exit") do
        puts opt
        exit
    end
    
end.parse!

#do the actual tagging:
text = ARGV[0]
if text and not text.empty?
    puts "tags: %s"%WebTagger.tag(text, service).inspect[1..-2] rescue puts "Couldn't extract tags"
else
    puts "You must supply some text to tag!"
end
